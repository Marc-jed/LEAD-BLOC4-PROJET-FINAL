import pandas as pd
import pytest
from Airflow.Dags.new_meteo import transform_meteo

list_col = ['POSTE',
 'DATE',
 'RR',
 'QRR',
 'DRR',
 'QDRR',
 'TN',
 'QTN',
 'HTN',
 'QHTN',
 'TX',
 'QTX',
 'HTX',
 'QHTX',
 'TM',
 'QTM',
 'TMNX',
 'QTMNX',
 'TNSOL',
 'QTNSOL',
 'TN50',
 'QTN50',
 'DG',
 'QDG',
 'TAMPLI',
 'QTAMPLI',
 'TNTXM',
 'QTNTXM',
 'PMERM',
 'QPMERM',
 'PMERMIN',
 'QPMERMIN',
 'FFM',
 'QFFM',
 'FXI',
 'QFXI',
 'DXI',
 'QDXI',
 'HXI',
 'QHXI',
 'FXY',
 'QFXY',
 'DXY',
 'QDXY',
 'HXY',
 'QHXY',
 'FF2M',
 'QFF2M',
 'FXI2',
 'QFXI2',
 'DXI2',
 'QDXI2',
 'HXI2',
 'QHXI2',
 'FXI3S',
 'QFXI3S',
 'DXI3S',
 'QDXI3S',
 'HXI3S',
 'QHXI3S',
 'UN',
 'QUN',
 'HUN',
 'QHUN',
 'UX',
 'QUX',
 'HUX',
 'QHUX',
 'DHUMI40',
 'QDHUMI40',
 'DHUMI80',
 'QDHUMI80',
 'TSVM',
 'QTSVM',
 'DHUMEC',
 'QDHUMEC',
 'UM',
 'QUM',
 'INST',
 'QINST',
 'GLOT',
 'QGLOT',
 'DIFT',
 'QDIFT',
 'DIRT',
 'QDIRT',
 'SIGMA',
 'QSIGMA',
 'INFRART',
 'QINFRART',
 'UV_INDICEX',
 'QUV_INDICEX',
 'NB300',
 'QNB300',
 'BA300',
 'QBA300',
 'NEIG',
 'QNEIG',
 'BROU',
 'QBROU',
 'ORAG',
 'QORAG',
 'GRESIL',
 'QGRESIL',
 'GRELE',
 'QGRELE',
 'ROSEE',
 'QROSEE',
 'VERGLAS',
 'QVERGLAS',
 'SOLNEIGE',
 'QSOLNEIGE',
 'GELEE',
 'QGELEE',
 'FUMEE',
 'QFUMEE',
 'BRUME',
 'QBRUME',
 'ECLAIR',
 'QECLAIR',
 'ETPMON',
 'QETPMON',
 'ETPGRILLE',
 'QETPGRILLE',
 'UV',
 'QUV',
 'TMERMAX',
 'QTMERMAX',
 'TMERMIN',
 'QTMERMIN',
 'HNEIGEF',
 'QHNEIGEF',
 'NEIGETOTX',
 'QNEIGETOTX',
 'NEIGETOT06',
 'QNEIGETOT06',
 "production en échec (la commande contient une plage d'absence de données)"]

def test_load_data(meteoday_get, list_col):
    if meteoday_get.empty:
        pytest.skip('Aucun fichier météo disponible')
    assert meteoday_get.shape[1] == 137
    col_missing = [c for c in list_col if c not in meteoday_get.columns]
    assert not col_missing, f"Colonnes manquantes: {col_missing}"



list_col2 = ['POSTE',
 'DATE',
 'RR',
 'DRR',
 'TN',
 'HTN',
 'TX',
 'HTX',
 'TM',
 'TMNX',
 'TNSOL',
 'TN50',
 'TAMPLI',
 'TNTXM',
 'FFM',
 'FXI',
 'DXI',
 'HXI',
 'FXY',
 'DXY',
 'HXY',
 'FXI3S',
 'HXI3S',
 'UN',
 'HUN',
 'UX',
 'HUX',
 'DHUMI40',
 'DHUMI80',
 'TSVM',
 'UM',
 'ORAG',
 'BRUME',
 'ETPMON',
 'ETPGRILLE',
 'production en échec (la station ne contient pas de donnée pour cette période)',
 'moyenne_precipitations_année',
 'moyenne_precipitations_mois',
 'moyenne_evapotranspiration_année',
 'moyenne_evapotranspiration_mois',
 'moyenne_vitesse_vent_année',
 'moyenne_vitesse_vent_mois',
 'moyenne_temperature_année',
 'moyenne_temperature_mois',
 'jours_TX_sup_30',
 'jours_sans_pluie',
 'ETPGRILLE_7j']

def test_cleaner_data(data_for_test, list_col2):
    test = transform_meteo(data_for_test)
    assert data_for_test.shape[1] < test.shape[1]
    for col in list_col2:
        assert col in test.columns, f"colonne manquante après nettoyage : {col}"
    
    # vérifer qu'il n' ait plus de colonne object
    object_col = test.select_dtypes(include="object").columns
    assert len(object_col) == 0, f'Colonne encore en object :{list(object_col)}'

    # vérifier qu'il n'y ait plus de virgule
    float_col = test.select_dtypes(include=["float64", "Float64"]).columns
    for col in float_col:
        has_comma = test[col].astype(str).str.contains(',', regex=False).any()
        assert not has_comma, f"Des virgules trouvées dans la colonne float {col}"




